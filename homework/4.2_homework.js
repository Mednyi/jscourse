'use strict';
/*
1. Создать замыкание "инкремент", каждый раз возвращающее новое значение счетчика, отличающееся от предыдущего на 1.
2. С использованием функции-генератора объектов (или любого другого способа) и замыкания "инкремент" сгенерировать 
два взаимосвязанных массива объектов (папка и файл) и объединить их в один объект. 
В файле хранится ссылка на id содержащей его папки.
Пример:
data: {
   folders: [
     {
         id: 1 // id сгенерировано с помощью замыкания "инкремент"
     }
   ],
   files: [
      {
        folderId: 1 // ссылка на папку, сгенерировано с помощью замыкания "инкремент"
      }
   ]
}

Подсказка: создать функцию которая генерирует id с помощью замыкания, папку с этим id,
а затем сразу генерирует файлы этой папки, далее опять генерирует новый id, новую папку и ее файлы уже для этого id,
и так несколько раз (в зависимости от того сколько папок хотите, но не меньше 3)

3. С использованием данной функции getData: 

const getData = path => new Promise((resolve, reject) => {
    const result = data[path];
    setTimeout(resolve, 5000, result);
});

Написать асинхронную функцию, получающую все папки: getFolders
Написать асинхронную функцию, получающую все файлы папки по ее id: getFiles(folderId)
Написать асинхронную функцию, использующую getFolders, а затем getFiles для любой из папок
и выводящую полученные данные на экран.
*/

//1. Создать замыкание "инкремент", каждый раз возвращающее новое значение счетчика, отличающееся от предыдущего на 1.
const generateId = () => { // функция для генерации id
    let i = 0; // объявляем переменную ДО функции увеличения ее значения на единицу ДЛЯ сохранения этой переменной в памяти и создания замыкания
    return function () { // инкремент
        return i++; // увеличивает на единицу объявленную выше переменную
    };
 
};

// 2. С использованием функции-генератора объектов (или любого другого способа) и замыкания "инкремент" сгенерировать два взаимосвязанных массива объектов (папка и файл) и объединить их в один объект.
const createFolder = (folderId) => ({folderId}); // ф-я созl/ объект, в объект передается значение FolderId для заполн. свойства FolderId объекта
const createFile = (id, folderId) => ({id, folderId}); // ф-я созд. объект со свойствами id, folderId, в которые сразу передаются соотв. значения для свойств объекта

const createData = () => { // функция для создания данных
    let folders = []; // создаем массив для папок
    let files = []; // создаем массив для файлов
    let folderIdGenerator = generateId(); // создаем отдельно, чтобы у каждого счетчика id был свой i, сейчас он =0
    let fileIdGenerator = generateId(); // создаем отдельно, чтобы у каждого счетчика id был свой i, сейчас он =0
    for(let i = 1; i < 10; i++) { // задаем условия для счетчика айдишников папок
        const folderId = folderIdGenerator(); // запускаем счетчик, получаем значение для свойства FoldeIid объекта folder
        const folder = createFolder(folderId); // создаем объект, в который передаем айди, полученный при помощи счетчика
        folders.push(folder); // добавляем созданный объект в массив folders
            for(let i = 1; i < 10; i++) { // задаем условия для счетчика айдишников файлов
            const fileId = fileIdGenerator(); // запускаем счетчик, получаем значение для свойства id объекта file
            const file = createFile(fileId, folderId); // создаем объект, передаем в него оба айдишника для соотв. свойств
            files.push(file); // добавляем созданный объект в массив files
            }
    }
    return {folders, files}; // возвращаем объект, в котором будут массивы folders и files
};

const data = createData(); // вызов функции для создания данных

// 3. С использованием данной функции (см. ниже)
const getData = path => new Promise((resolve, reject) => { // промис для получения данных из созданного объекта data, на вход принимает путь
    const result = data[path]; // результат промиса данные по указанному пути (обращение как в ассоциативном массиве)
    setTimeout(resolve, 5000, result); //setTimeout позволяет вызвать функцию один раз через определённый интервал времени, указывается условие выполнения resolve, интервал 5 секунд, и то, что промис должен вернуть
});

// Написать асинхронную функцию, получающую все папки: getFolders
const getFolders = async () => {
    return await getData('folders'); // ожидание выполнения промиса getData для пути folders
};

// Написать асинхронную функцию, получающую все файлы папки по ее id: getFiles(folderId)
const getFilesFromFolder = async folderId => {
    let files = await getData('files'); // ожидание выполнения промиса getData для пути files
    let filesFromFolder = files.filter(file => file.folderId === folderId); // СКОПИРОВАЛА, НЕ ПОНЯЛА ЗАПИСЬ
    return filesFromFolder
};

// Написать асинхронную функцию, использующую getFolders, а затем getFiles для любой из папок и выводящую полученные данные на экран.

const logFilesFromFolder = async () => { // МОЖНО ЛИ В ФУНКЦИЮ ПЕРЕДАТЬ АЙДИШНИК ПАПКИ, КАК?
    let folders = await getFolders(); // используем getFolders чтобы получить массив с папками из объекта data
    let files = await getFilesFromFolder(folders[5].id); // для получения файлов с определенным айди папки используем функцию getFilesFromFolder, в которую передаем айди папки (обращение к папке по номеру как к элементу массива, айди папки через точку как свойство объекта)
    console.log(files); // выводим папки в консоль
};

logFilesFromFolder();// НЕ РАБОТАЕТ — PENDING